# 操作系统 复习整理

PB19051150	罗兴攀

## 第一章

操作系统：实现对系统资源进行管理和控制程序执行的一种系统软件。

多道程序设计（multi-programming):程序的阻塞和等待引起CPU空转。在内存中保存多个任务，通过合理安排使CPU总是在执行一个任务，可以提高CPU利用率

多任务（multi-tasking):CPU频繁切换任务，使用户可以交互。

系统调用：程序需要操作系统提供的一些服务，所以操作系统就为用户程序提供了系统服务的接口，用户程序调用API，API调用系统调用来完成系统操作。

操作系统的不确定性是指系统中的每个程序执行时间，执行顺序的不确定性，而不是指结果不确定。

进程：进程是执行的程序。程序本身不是进程，程序是被动实体，而进程是活动实体。

僵尸进程：一个进程在已经结束自己生命，但其父进程还未对其回收完毕时称为僵尸进程。僵尸进程不在被调度，所有的用户空间内存与大部分已分配的内核内存被清理，仅在PCB中记载该进程的退出状态等信息，供其它进程收集。

死锁：两个或多个进程无限等待一个事件，而这个事件只能由等待的进程来产生，当出现这样的状态时，这些进程就成为死锁。

死锁要求：互斥、占有并等待、非抢占、循环等待。

打开文件表：**内核对所有打开的文件维护一个系统级别的打开文件表**，存储里与一个打开文件相关的全部信息，包括文件偏移量、状态标志信息，inode对象指针等。

通过打开文件表，将已打开的文件信息缓存在内存中，进而通过打开文件表完成文件索引，**避免每次访问需要目录遍历**，减少IO开销，提高性能。另一方面，全局下打开文件表可以维护一个文件的打开状态，确认当前是否正在被使用，以正确的进行删除等操作。

FAT的优缺点：

优点：更好的随机访问性能

缺点：缓存整个FAT表占用内存较多，需要通过部分缓存来平衡时间性能开销

硬链接与软链接：

* 硬链接：创建一个目录条目指向一个存在的文件；硬链接条目和原条目指向同一个inode;对应的link count+1,实际上是一个文件有两个路径。
* 软连接（符号链接）：创造一个新的目录条目和inode，它的目录条目指向这个新的inode；新的inode里存储的是指向的文件路径；对应link cout没有改变，实际上可以看作是一个文件的快捷方式。

数据日志与元数据日志的区别：

* 流程不同：
  * 数据日志：先写日志，再写文件系统
  * 元数据日志：先将元数据写入日志，数据写入文件系统，日志提交后再写元数据到文件系统
* 写入数据量不同：
  * 数据日志：数据写了两次
  * 元数据日志：数据只写了一次

I/O控制方法：

轮询、中断、直接内存访问（DMA)

内核IO子系统提供的服务：IO调度、缓冲、缓存、假脱机、错误处理和IO保护。

### 信号量

信号量是一个整型变量，只能通过两个标准原子操作被访问，表示所空闲的资源的数量。

功能：互斥、计数、同步。

#### 读者-写者问题：

##### 读者优先：

```c++
//写者进程
while(true):
	P(rw) // 写之前占用临界区资源
    /** 临界区写文件 **/
    V(rw) // 写完后释放临界区资源
        
//读者进程
while(true):
	P(mutex)
        readcnt+=1 // 访问临界区的读者进程数+1
    	if(readcnt==1) // 第一个读者进程负责占用临界区资源
            P(rw)
    V(mutex)
    /** 临界区读文件 **/
	P(mutex)
        readcnt-=1 // 访问临界区的读者进程数-1
    	if(readcnt==0) // 最后一个读者进程负责释放临界区资源
            V(rw)
    V(mutex)
```

##### 读写公平

```c++
//写者进程
while(true):
	P(w) // 读进程和写进程哪个先来到就会先拿到w资源
        P(rw) // 写之前占用临界区资源
        /** 临界区写文件 **/
        V(rw) // 写完后释放临界区资源
    V(w)
//读者进程
while(true):
	P(w) // 读进程和写进程哪个先来到就会先拿到w资源
        P(mutex)
        	readcnt+=1 // 访问临界区的读者进程数+1
            if(readcnt==1) // 第一个读者进程负责占用临界区资源
                P(rw) 
        V(mutex)
    V(w)
    /** 临界区读文件 **/
    P(mutex)
        readcnt-=1 // 访问临界区的读者进程数-1
        if(readcnt==0) // 最后一个读者进程负责释放临界区资源
            V(rw)
    V(mutex)

```

##### 写者优先

```c++
//写者进程
while(true):
    P(mutex)
        writecnt+=1 // 只要有读进程来了，writecnt+1
    V(mutex)
    P(rw) // 写之前占用临界区资源
    /** 临界区进行写 **/
    V(rw) // 写完后释放临界区资源
    P(mutex1)
        writecnt-=1 // 写完了writecnt-1
        // 没有写者想写 且 有读者正阻塞在P(read) 就释放read让读者读文件
        if(writecnt==0 && waiting):
            V(read)
            waiting = false 
            // 如果没有waiting，可能导致没有读者时写者会V(read)导致read资源变多
    V(mutex1)
//读者进程
 while(true):
    P(mutex3)  // 如果没有mutex3，可能造成多个读进程阻塞在P(read)
        if(writecnt!=0): // 一旦有写者来了，后来的读者就要等待写者写完
            waiting = true // 表明现在有读者在等写者
            P(read) // 要等写者写完才可以继续
    V(mutex3)
    P(mutex2)
        readcnt+=1
        if(readcnt==1): // 第一个读者进程负责占用临界区资源
            p(rw)
    V(mutex2)
    /** 临界区进行读 **/
    P(mutex2)
        readcnt-=1
        if(readcnt==0): // 最后一个读者进程负责释放临界区资源
            V(rw)
    V(mutex2)
```

#### 独木桥问题

```c++
monitor bridge {
	int num_waiting_north = 0;
	int num_waiting_south = 0;
	int on_bridge = 0;
	condition ok_to_cross;
	int prev = 0;
void enter_bridge_north() {
	num waiting_north++;
	while (on_bridge ||
		(prev == 0 && num_waiting_south > 0))
	ok_to_cross.wait();
	num_waiting_north--;
	prev = 0;
}
void exit_bridge_north() {
	on_bridge = 0;
	ok_to_cross.broadcast();
}
void enter_bridge_south() {
	num_waiting_south++;
	while (on_bridge ||
		(prev == 1 && num_waiting_north > 0))
	ok_to_cross.wait();
	num_waiting_south--;
    prev = 1;
}
void exit_bridge_south() {
	on_bridge = 0;
	ok_to_cross.broadcast();
} 
}
```

并发与并行：

并发：有处理多个任务的能力，不一定要同时。

并行：有同时处理多个任务的能力。



```
今年题型与往年相同，分为填空、名词解释、简答、计算、编程题。

以下是回忆内容，前三大题回忆不全，仅供参考：

(1) 填空题：操作系统定义（汤书内容，第一次ppt有），信号量的类型和作用。
操作系统是软件与硬件之间的接口，是资源的管理者。
信号量分为计数信号量的二进制信号量。信号量可以用来提供互斥，计数信号量可以用于控制访问具有多个实例的某种资源，信号量也可以用于解决各种同步问题。
(2) 名词解释：VFS，进程基本状态，RAID1，基本IO控制方式（轮询、中断、DMA、通道）。
VFS:虚拟文件系统。为用户程序提供文件和文件系统操作的统一接口，屏蔽不同文件系统的差异和操作细节。借助VFS可以直接使用open()、read()、write()这样的系统调用操作文件，而无须考虑具体的文件系统和实际的存储介质。
进程的基本状态：新的，等待，就绪，运行，终止。
RAID1:数据写入磁盘时，在另一个备份磁盘上写入同样的数据，当一个磁盘损坏时，可以从备份磁盘中获取正确结果。磁盘利用率为0.5
RAID5:有n个磁盘，n-1个存储数据，剩余一个存储检验码，且校验码分布在各个磁盘上。磁盘利用率为
(n-1)/n.
需要注意，名词解释不是写出名字就行，比如VFS，仅写出虚拟文件系统是不够的，还需要答出它的含义/作用。

(3) 简答题：FAT和iNode的含义与优缺点。

(4) 计算题：磁盘调度，死锁避免 - 银行家算法（我们班讲了，隔壁班未细讲），从用户态进入内核态的具体过程（为什么这个是计算题？）。

(5) 编程题：信号量编程题。题目提供实际情景，进行模型判断（本次为生产者-消费者），然后写出代码。

需要注意，本题重点考察的是信号量的运用，是进程同步部分的知识。代码可以写伪代码；定义信号量时，一定要记得初始化；不要忘记互斥信号量mutex；不要写成串行、死锁。
```

**地址重定位就是操作系统将逻辑地址转变为物理地址的过程**

* 静态重定位是在程序执行之前进行重定位，静态重定位有着无需硬件支持的优点，但存在着如下的缺点：一是程序重定位之后就不能在内存中搬动了；二是要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域内。
* 动态重定位是指，不是在程序执行之前而是在程序执行过程中进行地址重定位。更确切地说，是在CPU每次访问内存单元前才进行地址变换。动态重定位对于存储器紧缩、解决碎片问题是极其有利的。动态重定位不在要求程序放在连续的内存区域。

**动态重定位技术所付出的代价是需要硬件支持。**

分段与分页的区别：分页是出于系统管理的需要，分段是出于用户应用的需求。页大小是固定的，而段大小通常不固定。分页是一维的，分段是二维的。段式可以内存共享，而页式不能。分页有内部碎片，但没外部碎片。分段没有外部碎片但有内部碎片。

数据分段：

* 代码段：存放可执行程序的指令
* 数据段：存放已初始化的数据（非零初始化的全局变量和静态局部变量）
* BSS段：未初始化（未初始化或者初始化为0的全局变量和静态局部变量）
* 堆：动态分配内存。malloc手动申请，free释放
* 栈：存放函数局部变量，函数参数和返回值。

.data是初始化的数据，.bss表示未初始化的数据。.bss并不 占用可执行文件的大小，仅仅记录需要用多少空间来存储这些未初始化的数据，而不分配实际空间。

**段错误：**

当你访问一块不允许访问的内存时，操作系统就会返回一个“段错误”。例如：向未使用或未申请的段读

取内容，向只读段写内容，向未使用或未申请段写内容。

银行家算法：

安全算法：

```
Need=Max-Allocation.
Work=Available.
while(true){
	if(Need[i]<Work){	//找到一个i序列
		Finish[i]=true;
		Work=Work+Need[i];
	}
	if (all Finsish[i] = true) break; 
}
```

请求算法：

```
if(Request[i]<=Need[i]){
分配：
	Available=Available-Request[i];
	Allocation[i]=Allocation[i]+Request[i];
	Need[i]=Need[i]-Request[i];
	if(分配完成后，安全检测通过){
		可以分配。
	}
	else{不允许分配，分配后不安全}
}
else{不允许分配，资源不够分配}
```

